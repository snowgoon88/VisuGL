* Dependance
** OpenGL
** GLFW - Window with OpenGL
** FTGL - Draw text with OpenGL and FreeType2
** GSL - Gnu Scientific Library
** BOOST - Boost::program_options
* DONE [2/2] Fenêtre GLFW version 3 
** DONE CMake pour GLFW
** DONE C++ pour GLFW
* [5/6] Afficher Graphe
** TODO Afficher Grille
** DONE [4/4] Afficher Axes avec ticks et range
*** DONE Label
 => Attention, le fait de scaler par rapport au glOrtho fait que les lettres ne sont pas jolie.
*** DONE Major Ticks
*** DONE Minor Ticks
*** DONE Ticks Label
** DONE Afficher text avec FTGL
 =>  FTGLTextureFont
** DONE Taille du texte en fonction de la taille de la fenêtre (ratio).
** DONE Position du texte en fonction de la taille de la fenètre (ratio)
** DONE Afficher Courbe

* DONE [1/1] Constructeurs, Copy, Move
** DONE tester Copy pour Layer
* TODO [3/4] BICA -HMM
** Séquence
wbuild/xp/xp-003-hmm --create_hmm "AAAAF" --save_hmm my_hmm
wbuild/xp/xp-003-hmm -m my_hmm --length_traj 1000 --save_traj my_traj
wbuild/xp/xp-003-hmm -m my_hmm -t my_traj --res_size 10 --save_esn my_esn 
wbuild/xp/xp-003-hmm -m my_hmm -t my_traj -e my_esn --noise_length 500 --save_noise my_noise
wbuild/xp/xp-003-hmm -m my_hmm -t my_traj -e my_esn -o my_res00 -g
wbuild/xp/xp-003-hmm -m my_hmm -t my_traj -e my_esn -n my_noise.dat -o my_res01 -g

** hmm.hpp (et input.hpp)
HMM est une paire de deux fontion
- une qui donne le prochain état          (int) -> int
  typedef std::function<int(int)>    T;
- une qui donne la prochaine observation  (int) -> double
  typedef std::function<double(int)> O;
*** peut définir des HMM avec string : make( string )
std::string("ABCD"),           // periodic
"AB*D",                        // periodic, mais avec *=uniform obs
"+ ABC & DEF",                 // suite de 2 HMM
"! .05 ABCD",                  // bruit gaussien sur obs
"+ ! .05 ABC & DEF",           // suite gaussien puis deterministe
"| .05 ABC .05 DEF",           // alterne entre deux deterministes
"| .05 ! .05 ABCD .01 *",      // alterne entre 1) Gaussien 2) random O
"| 0.03 ! 0.05 AAAAAAAAAAF 0.1 | 0.5 A 0.5 F"
                               // alterne 1) AAAAAAAAAAAF gaussien
                               //         2) soit A, soit F
** DONE test-hmm.cpp
** DONE [3/3] Apprendre (o)_t -> o_{t+1} avec réservoir
*** DONE générer trajectoire HMM
*** DONE initialiser différemment ESN (Szita)
*** DONE xp-003-HMM
** TODO [0/1] Visualization with R
*** TODO Tester si autres scripts marchent.
** DONE visualization on-line
* TODO Rec-SOM
* [/] Data
** DONE McKey-Glass
*** DONE Serialiser avec gaml::make-output_iterator ?
=> son propre reader/writer
* TODO [3/4] Reservoir Computing
** DONE Serialiser
** DONE Learn
Mise en place de Ridge Regression
** DONE [2/4] Reservoir
*** DONE GSL => valeurs propres complexes
Comment c'est fait dans Matlab : Magnitude du complexe
*** DONE Copie de la matrice avant les calculs
*** TODO C++ Matrix
BLAZE : https://code.google.com/p/blaze-lib/
Eigen
*** TODO Iterator ??
http://stackoverflow.com/questions/7758580/writing-your-own-stl-container/7759622#7759622

** TODO Cherche le meilleur Ridge Coef
* TODO Data en séquence
* TODO [7/10] XP POMDP 
J'ai l'impression qu'essayer d'apprendre les transitions ne marche que dans des cas quasi déterministes, non? Dans ce cas, faudrait plutôt essayer de voir si on peut pas apprendre V(s) ou V(o) ??
** DONE ajout d'un jsonreader pour transition
** DONE Générer et sauvegarder une trajectoire de transitions
** DONE Cheese maze labyrinthe
Voir début danns xp/xp-002-cheese-maze
** DONE Memory Leak
** DONE Sauvegarder les résultats
** DONE pour apprendre il faut traj+pomdp (nb obs, etc)
** DONE [4/4] Comprendre le format de fichier de sortie -> R
*** GEN pomdp cheese
wbuild/xp/xp-002-cheese -p 0.9 -l 1 -f cheese_maze_0.9_1
*** GEN trajectoire
wbuild/xp/xp-001-pomdp -p data_xp/cheese_maze_0.9_1.json --gene_traj data_xp/traj_1000 --traj_length 1000
*** GEN esn
wbuild/xp/xp-001-pomdp -p data_xp/cheese_maze_0.9_1.json --gene_esn esn_50_1_0.99_0.1 --res_size 50
*** GEN noise
wbuild/xp/xp-001-pomdp -p data_xp/cheese_maze_0.9_1.json --gene_noise noise_1000_0.1 --length_noise 1000
*** DONE LEARN
*** DONE LEARN Paremeters
wbuild/xp/xp-001-pomdp -p data_xp/cheese_maze_0.9_1.json -t data_xp/traj_1000.data -e data_xp/esn_50_1_0.99_0.1.json --regul 10.0 -o data_xp/result_10.data
*** DONE LEARN results with comment and header
*** DONE [Q] : biais dans réservoir ? => OUI
d'après [Lukosevicius12]
** [11/13] TODO Scripts pour tester influence des paramètres
## calculer taux erreur pour chaque fichier
df.sum <- make_df_pomdp( "data_xp" )
## sauvegarde
write.table( df.sum, file="data_xp/df_sum.rdata", row.names=FALSE, sep="\t")
## Fait en plusieurs lots qu'on charge ensuite
df <- rbind( df.sum.500, df.sum.1000, df.sum.2000, df.sum.10000 )
*** TODO PT Max id : ltraj lesn leak regul
voir dans [[bac_learnpomdp.R]]
## Faire les moyenne
attach(df.sum)
df.mean <- aggregate(df.sum[,c("rate_le","mse_le")], by=list(ltraj,lesn,leak,regul,ltest,type), FUN=mean)
detach( df.sum )
## Remplacer "Groupe.1" par son 'vrai nom
names(df.mean)[1:6] <- c("ltraj","lesn","leak","regul","ltest","type")
## trouver le max de rate_le
attach( df.mean )
which.max( rate_le )
## etc
## Ordonner le dataframe en fonction de rate_le
df.maxrate <- df.mean[ order(-rate_le),]
## On peut ensuite afficher, puis imprimer, en cliquant dessus.

*** DONE Visualier autour d'un point
res <- mk_query( list(1000,100,0.1,0.1,10,"test"))
subd <- get_filenames( df.sum, list(1000,100,0.1,0.1,10,"test"))
lp <- plot_traj_esn( subd, esn=6, str.title=res\[[3 ]\] )
## Ce qui se fait aussi avec 
p <- look_traj( df.sum, list(500,100,0.5,1,100,"test"), 2)
subd.test05 <- p[[1]]
str.test05 <- p[[2]]
pt.test05 <- p[[3]]
plot_traj_esn( subd.test05, esn=6, str.title=str.test05)
plot_traj_esn( subd.test05, esn=9, str.title=str.test05)

**** <2016-05-24 Tue>
Sauvegarde de l'environnement R autour de data_xp dans "env_data_xp.R"

*** DONE Tester sur traj test !!
*** DONE Afficher variation autour PT Max dans chacune des 4 dimensions (3 fixe)
*** DONE R-Script : générer les noms des fichiers results
*** DONE R-Script : utiliser 'by' pour faire des moyennes, des variances
*** DONE Regarder Variabilité Traj et Output dans 100  200  0.5   0.1
*** DONE Reprendre script python
ATTENTION : il faut générer un ESN par run de l'expérience.
**** subprocess.Popen 
     avec Popen.poll() et Popen.wait()
*** DONE taille Res
*** DONE Leaking rate
*** DONE regul
*** noise
*** noise length
*** DONE traj size
*** TODO Sauvegarder les points pt.test* importants

** TODO [1/4] apprendre (0+A) -> .
*** TODO pour apprendre, il faut transition ->O
*** DONE pour apprendre, il faut transition ->S (pour voir)
**** <2016-04-20 Wed>
l_traj_size = [500,1000,2000,10000]
l_esn_size = [10,50,100]
l_regul = [0.01, 0.1, 1.0, 10.0]
l_leak = [0.1,0.5,0.9]
l_test_length = [10,100,1000]
nb_traj    = 5       ## how many instances of each traj config
nb_esn     = 10      ## how many instances of each esn config
nb_repeat  = 1       ## no need to repeat : deterministic learning
nb_start   = 0       ## start numbering files with
generate   = True    ## need to generate traj,esn
data_xp/result_traj_size_esn_size_leak_regul_Eesn_Ttraj.data_nb_test/learn
*** TODO pour apprendre, il faut transition ->V(S) (pour voir)
**** TODO <2016-05-23 Mon>
l_traj_size = [500,1000,2000,10000]
    l_esn_size = [10,50,100]
    l_regul = [0.01, 0.1, 1.0, 10.0]
    l_leak = [0.1,0.5,0.9]
    l_test_length = [10,100,400]
    
    nb_traj    = 5       ## how many instances of each traj config
    nb_esn     = 2      ## how many instances of each esn config
    nb_repeat  = 1       ## no need to repeat : deterministic learning
    nb_start   = 0       ## start numbering files with
    generate_traj = False    ## need to generate traj
    generate_esn  = True     ## need to generate traj
    learn         = True    ## learn
*** TODO pour apprendre, il faut tansition ->V(O) (pour voir)
** TODO [0/3] apprendre A x (O -> .) 
*** TODO pour apprendre, il faut transition ->O
*** TODO pour apprendre, il faut transition ->S (pour voir)
*** TODO pour apprendre, il faut transition ->V(S) (pour voir)
* [0/1] Utils
** TODO Un seul namespace dans utils, la différence se fera par l'objet que l'on veut striser
* [3/3] Check Ridge Regression
https://onlinecourses.science.psu.edu/stat857/node/155
http://www.astrostatistics.psu.edu/su07/R/html/MASS/html/lm.ridge.html
** DONE RidgeReg with GIVEN regul param
** DONE Compare with R
** DONE Ne pas accorder de pénalité pour le poids associé à 'intercept' dans RR
